from abc import ABC, abstractmethod
import os
from instrupy.base import Instrument
import pandas as pd
from chess3d.messages import *
from chess3d.agents.science.requests import TaskRequest, TaskRequest
from chess3d.mission import *

class DataProcessor(ABC):
    """
    # Data Processor
    Processes observation data and provides ev
    """
    def __init__(self, parent_name : str, event_mission : Mission):
        super().__init__()
    
        self.parent_name = parent_name                          # name of parent agent
        self.event_mission = event_mission                      # mission of parent agent when events occur

        self.event_requesters : dict[str, GeophysicalEvent] = dict() # event requesters
        self.known_events : set[GeophysicalEvent] = set()       # events known to me (generated by me or others)
        self.detected_events : set[GeophysicalEvent] = set()    # events detected by me only

        self.known_reqs : set[TaskRequest] = set()              # requests known to me (generated by me or others)
        self.generated_reqs : set[TaskRequest] = set()          # requests generated by me only

    # @runtime_tracker
    def process_observations(self, incoming_reqs : list, observations : list) -> list:
        
        # unpack incoming requests
        incoming_reqs : list[TaskRequest]
        incoming_detected_events = {req.event for req in incoming_reqs 
                                    if isinstance(req, TaskRequest)
                                    and req.event is not None}
        incoming_event_requesters = {req.event : req.requester 
                                     for req in incoming_reqs
                                     if isinstance(req, TaskRequest)
                                     and req.event is not None}
        
        # update list of known events and requests
        self.known_events.update(incoming_detected_events)
        self.known_reqs.update(incoming_reqs)

        # update list of event requesters
        self.event_requesters.update(incoming_event_requesters)

        # initiate requests generated
        requests : list[TaskRequest] = list()

        # process observations
        for instrument,observation_data in observations:
            for obs in observation_data:
                # process observation
                event : GeophysicalEvent = self.process_observation(instrument, obs)

                # no event in observation; skip
                if event is None: continue

                # event has already been detected; skip
                if event in self.known_events: continue

                # get event objetives from mission
                objectives = [objective for objective in self.event_mission.objectives
                              if objective.event_type == event.event_type]
                objectives : list[EventDrivenObjective] 
                for objective in objectives: objective.t_end = event.t_end

                # generate task request 
                task_request = TaskRequest(self.parent_name,
                                           event,
                                           self.event_mission.name,
                                           objectives,
                                           obs['t_end'])
                
                # update list of known and detected requests
                self.known_events.add(event)
                self.known_reqs.add(task_request)

                self.detected_events.add(event)
                self.generated_reqs.add(task_request)

                self.event_requesters[event] = self.parent_name

                # update list of generated requests 
                requests.append(task_request)

        # return list of generated requests
        return requests    

    @abstractmethod
    def process_observation(self, 
                            instrument : Instrument,
                            **kwargs
                            ) -> tuple:
        """ Processes incoming observation data and returns the characteristics of the event being detected if this exists """

    
class LookupProcessor(DataProcessor):
    def __init__(self, events_path : str, parent_name : str, event_mission : Mission):
        """ 
        ## Lookuup Table Science Module

        Has prior knowledge of all of the events that will occur during the simulation.
        Compares incoming observations to a predefined list of events to determine whether an event has been observed.
        """
        super().__init__(parent_name, event_mission)

        # load predefined events
        self.events_lookup : list[GeophysicalEvent] = self.load_events(events_path)

        # extract detectable event types from mission objectives
        self.detectable_event_types = {objective.event_type 
                                       for objective in self.event_mission.objectives}

        # initialize update timer
        self.t_update = None

    def load_events(self, events_path : str) -> pd.DataFrame:

        if not os.path.isfile(events_path):
            raise ValueError('`events_path` must point to an existing file.')
        
        events_df : pd.DataFrame = pd.read_csv(events_path)

        events = []
        for _,row in events_df.iterrows():
            # convert event to GeophysicalEvent
            event = GeophysicalEvent(
                row['event type'],
                row['severity'],
                (row['lat [deg]'], row['lon [deg]'], row.get('grid index', 0), row['gp_index']),
                row['start time [s]'],
                (row['start time [s]'] + row['duration [s]']),
                row['decorrelation time [s]'],
                row['id']
            )
            events.append(event)

        return events
    
    def process_observation(self, 
                            instrument : str,
                            obs : dict
                            ) -> tuple:
        
        t_img_start = obs['t_start']
        t_img_end = obs['t_end']
        lat = obs['lat [deg]']
        lon = obs['lon [deg]']
        
        # update list of events to ignore expired events
        if self.t_update is None or abs(self.t_update - t_img_start) > 100.0:
            self.events_lookup = [event for event in self.events_lookup if event.is_active(t_img_start) or event.is_future(t_img_start)]
            self.t_update = t_img_start

        observed_events = [ event
                            for event in self.events_lookup
                            # same location as the observation
                            if abs(lat - event.location[0]) <= 1e-3
                            and abs(lon - event.location[1]) <= 1e-3
                            # availability during the time of observation
                            and (event.t_start <= t_img_start <= event.t_end
                                 or event.t_start <= t_img_end <= event.t_end)
                            # event requires observations of the same type as the one performed
                            # and instrument in event.event_type
                            # event has not been detected before
                            and (event.location[0],event.location[1],event.t_start,event.t_end-event.t_start,event.severity,event.event_type) not in self.detected_events 
                            # and event type is detectable by mission
                            and event.event_type in self.detectable_event_types
                            ]

        
        # return highest-severity event at that given target
        if observed_events:
            # sort by severity  
            observed_events.sort(key= lambda a: a.severity)
            
            # get next highest severity event
            event = observed_events[-1]
            
            return event

        return None