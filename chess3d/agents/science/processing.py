from abc import ABC, abstractmethod
import os
from instrupy.base import Instrument
import pandas as pd
from chess3d.messages import *
from chess3d.agents.science.requests import TaskRequest, TaskRequest
from chess3d.mission import *

class DataProcessor(ABC):
    """
    # Data Processor
    Processes observation data and provides ev
    """
    def __init__(self, parent_name : str, event_mission : Mission):
        super().__init__()
    
        self.parent_name = parent_name                          # name of parent agent
        self.event_mission = event_mission                      # mission of parent agent when events occur
        self.known_reqs : set[TaskRequest] = set()       # requests generated by me or others
        self.generated_reqs : set[TaskRequest] = set()   # requests generated by me only

    def process_observations(self, incoming_reqs : list, observations : list) -> list:
        
        # update list of known requests
        self.known_reqs.update(incoming_reqs)

        # initiate requests generated
        requests : list[TaskRequest] = list()

        # process observations
        for instrument,observation_data in observations:
            for obs in observation_data:
                # process observation
                event : GeophysicalEvent = self.process_observation(instrument, obs)

                # no event in observation; skip
                if event is None: continue

                # get event objetives from mission
                objectives = [objective for objective in self.event_mission.objectives
                              if objective.event_type == event.event_type]
                objectives : list[EventDrivenObjective] 
                for objective in objectives: objective.t_end = event.t_end

                # generate task request 
                task_request = TaskRequest(self.parent_name,
                                           event,
                                           objectives,
                                           obs['t_img'])
                
                # check if another request has already been made for this event
                if any([task_request.same_event(req) for req in self.known_reqs]):
                    # another request has been made for this same event; ignore
                    continue

                # update list of known and detected requests
                self.known_reqs.add(task_request)
                self.generated_reqs.add(task_request)

                # update list of generated requests 
                requests.append(task_request)

        # return list of generated requests
        return requests    

    @abstractmethod
    def process_observation(self, 
                            instrument : Instrument,
                            **kwargs
                            ) -> tuple:
        """ Processes incoming observation data and returns the characteristics of the event being detected if this exists """

    
class LookupProcessor(DataProcessor):
    def __init__(self, events_path : str, parent_name : str, event_mission : Mission):
        """ 
        ## Lookuup Table Science Module

        Has prior knowledge of all of the events that will occur during the simulation.
        Compares incoming observations to a predefined list of events to determine whether an event has been observed.
        """
        super().__init__(parent_name, event_mission)

        # load predefined events
        self.events : list[GeophysicalEvent] = self.load_events(events_path)

        # extract detectable event types from mission objectives
        self.detectable_event_types = {objective.event_type for objective in self.event_mission.objectives}

        # initialize empty list of detected events
        self.events_detected = set()

        # initialize update timer
        self.t_update = None

    def load_events(self, events_path : str) -> pd.DataFrame:

        if not os.path.isfile(events_path):
            raise ValueError('`events_path` must point to an existing file.')
        
        events_df : pd.DataFrame = pd.read_csv(events_path)

        events = []
        for _,row in events_df.iterrows():
            # convert event to GeophysicalEvent
            event = GeophysicalEvent(
                row['event type'],
                row['severity'],
                (row['lat [deg]'], row['lon [deg]'], 0.0),
                row['start time [s]'],
                (row['start time [s]'] + row['duration [s]']),
                row['decorrelation time [s]'],
                row['id']
            )
            events.append(event)

        return events
    
    def process_observation(self, 
                            instrument : str,
                            obs : dict
                            ) -> tuple:
        
        t_img = obs['t']
        lat = obs['lat [deg]']
        lon = obs['lon [deg]']
        
        # update list of events to ignore expired events
        if self.t_update is None or abs(self.t_update - t_img) > 100.0:
            self.events = [event for event in self.events if event.is_active(t_img) or event.is_future(t_img)]
            self.t_update = t_img

        observed_events = [ event
                            for event in self.events
                            # same location as the observation
                            if abs(lat - event.location[0]) <= 1e-3
                            and abs(lon - event.location[1]) <= 1e-3
                            # availability during the time of observation
                            and event.t_start <= t_img <= event.t_end
                            # event requires observations of the same type as the one performed
                            and instrument in event.event_type
                            # event has not been detected before
                            and (event.location[0],event.location[1],event.t_start,event.t_end-event.t_start,event.severity,event.event_type) not in self.events_detected 
                            # and event type is detectable by mission
                            and event.event_type in self.detectable_event_types
                            ]

        
        # return highest-severity event at that given target
        if observed_events:
            # sort by severity  
            observed_events.sort(key= lambda a: a.severity)
            
            # get next highest severity event
            event = observed_events[-1]
            
            # add event to list of detected events
            self.events_detected.update(event)

            return event

        return None