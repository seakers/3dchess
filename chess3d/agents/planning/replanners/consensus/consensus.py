import itertools
import logging
from queue import Queue
from typing import Dict
from tqdm import tqdm

from dmas.utils import runtime_tracker
from dmas.clocks import *

# from chess3d.agents.planning.rewards import GridPoint, RewardGrid
from chess3d.agents.states import SimulationAgentState
from chess3d.agents.planning.plan import Plan, Preplan, Replan
from chess3d.agents.planning.replanners.consensus.bids import Bid, BidComparisonResults, RebroadcastComparisonResults
from chess3d.agents.planning.planner import AbstractReplanner
from chess3d.agents.science.reward import *
from chess3d.orbitdata import OrbitData
from chess3d.agents.science.requests import *
from chess3d.agents.states import *
from chess3d.messages import *

class AbstractConsensusReplanner(AbstractReplanner):    
    def __init__(self, 
                 replan_threshold : int = 1,
                 debug : bool = False,
                 logger: logging.Logger = None
                 ) -> None:
        super().__init__(debug, logger)

        # initialize variables
        self.active_requests : set[TaskRequest] = set()
        self.bundle = []
        self.results : Dict[str, Dict[str, Bid]] = dict()
        self.available_requests = set()
        self.bids_to_rebroadcast = []
        self.other_plans = {}
        self.recently_completed_observations = set()
        self.my_completed_observations = set()
        self.pending_reqs_to_broadcast : set[TaskRequest] = set()            # set of observation requests that have not been broadcasted
        self.planner_changes = []
        self.ignored_requests = set()
        self.agent_orbitdata : OrbitData = None
        self.preplan : Preplan = None
        self.plan : Plan = None

        # set paremeters
        self.replan_threshold = replan_threshold
        self.planning_horizon = np.Inf
        self.t_share = -1

    @runtime_tracker
    def update_percepts(self, 
                        state: SimulationAgentState, 
                        current_plan: Plan, 
                        incoming_reqs: list, 
                        relay_messages: list, 
                        misc_messages: list, 
                        completed_actions: list, 
                        aborted_actions: list, 
                        pending_actions: list, 
                        ) -> None:
       
        # update other percepts
        super().update_percepts(state,
                                current_plan,
                                incoming_reqs,
                                relay_messages,
                                misc_messages,
                                completed_actions,
                                aborted_actions,
                                pending_actions)
        
        # update list of known and active events
        self.active_requests = {req for req in self.known_reqs
                                if req.t_start <= state.t <= req.t_end}

        # check if new preplan was received
        if abs(state.t - current_plan.t) <= 1e-3 and isinstance(current_plan, Preplan): 
            # set latest preplan as current plan 
            self.plan = current_plan.copy()
            
        # collect list of measurement requests newly generated by the parent agent
        my_reqs = {req 
                    for req in incoming_reqs
                    if isinstance(req, TaskRequest)
                    and req.requester == state.agent_name}

        # update list of pending requests to broadcast
        self.pending_reqs_to_broadcast.update(my_reqs)

        # collect list of completed broadcasts
        completed_broadcasts = {message_from_dict(**action.msg) 
                            for action in completed_actions
                            if isinstance(action, BroadcastMessageAction)}
        
        # collect list of completed request broadcasts
        broadcasted_reqs = {TaskRequest.from_dict(msg.req) 
                            for msg in completed_broadcasts
                            if isinstance(msg, MeasurementRequestMessage)}
        
        # remove from list of pending requests to breadcasts if they've been broadcasted already
        self.pending_reqs_to_broadcast.difference_update(broadcasted_reqs)

        # update preplan
        self.preplan.update_action_completion(completed_actions, aborted_actions, pending_actions, state.t)

        # compile set of recently completed observation
        my_completed_observations, completed_observations \
            = self._compile_completed_observations(completed_actions, misc_messages)
        self.my_completed_observations : set[ObservationAction] = my_completed_observations
        self.recently_completed_observations : set[ObservationAction] = completed_observations

        # check if any new measurement requests have been received
        self.incoming_bids : set[Bid] = self.compile_new_measurement_request_bids(state, incoming_reqs)

        # update incoming bids
        self.incoming_bids.update({ Bid.from_dict(msg.bid) 
                                    for msg in misc_messages 
                                    if isinstance(msg, MeasurementBidMessage)})

        # check if any request refers to an action in the pre-plan
        for req in incoming_reqs:
            # find all observations that match a given request
            matching_planned_observations : list[ObservationAction] \
                = [action for action in self.preplan
                   if isinstance(action, ObservationAction)
                   and abs(action.targets[0] - req.target[0]) <= 1e-3
                   and abs(action.targets[1] - req.target[1]) <= 1e-3
                   and abs(action.targets[2] - req.target[2]) <= 1e-3
                   ]
            
            # remove from pre-plan
            for observation in matching_planned_observations: 
                self.preplan.actions.remove(observation)
        
    def _compile_completed_observations(self, 
                                        completed_actions : list, 
                                        misc_messages : list) -> set:
        """ Reads incoming precepts and compiles all measurement actions performed by the parent agent or other agents """
        # checks measurements performed by the parent agent
        my_completed_observations = { action for action in completed_actions
                                      if isinstance(action, ObservationAction)}
        
        # checks measuremetns performed by other agents
        completed_observations = {  action_from_dict(**msg.observation_action) 
                                    for msg in misc_messages
                                    if isinstance(msg, ObservationPerformedMessage) }
        completed_observations.update(my_completed_observations)

        # return lists of observations
        return my_completed_observations, completed_observations
    
    @runtime_tracker
    def compile_new_measurement_request_bids(self, 
                                             state : SimulationAgentState, 
                                             incoming_reqs : list) -> set:
        """ Checks for all requests that havent been considered in current bidding process """
        # check if incoming requests are considered in the bidding results
        reqs_not_in_results = {req for req in incoming_reqs if req.id not in self.results}

        # generate set of bids for all new requests
        new_request_bids : set[Bid]= { bid
                                        for req in reqs_not_in_results
                                        for bid in self._generate_bids_from_request(req, state)
                                    }

        if incoming_reqs:
            x =1

        return new_request_bids

    @abstractmethod
    def _generate_bids_from_request(self, req : TaskRequest, state : SimulationAgentState) -> list:
        """ Creages bids from given measurement request """    

    @runtime_tracker
    def needs_planning(self, 
                       state : SimulationAgentState, 
                       specs : object,
                       current_plan : Plan,
                       orbitdata : OrbitData
                       ) -> bool:   
                
        # perform consesus phase
        # ---------------------------------
        # DEBUGGING OUTPUTS 
        # self.log_results('PRE-CONSENSUS PHASE', state, self.results)
        # print(f'length of bundle: {len(self.bundle)}\nbids to rebroadcast: {len(self.bids_to_rebroadcast)}')
        # print(f'bundle:')
        # for req, subtask_index, bid in self.bundle:
        #     req : MeasurementRequest
        #     bid : Bid
        #     id_short = req.id.split('-')[0]
        #     print(f'\t{id_short}, {subtask_index}, {np.round(bid.t_img,3)}, {np.round(bid.bid)}')
        
        # if self.incoming_bids:
        #     x = 1
        # print('')
        # ---------------------------------

        self.results, self.bundle, \
            _, bids_to_rebroadcast = self.consensus_phase(state,
                                                            self.results,
                                                            self.bundle, 
                                                            self.incoming_bids,
                                                            self.recently_completed_observations)
        self.bids_to_rebroadcast.extend(bids_to_rebroadcast)
        
        path = self.path_from_bundle(self.bundle)

        if self._debug: assert self.is_task_path_valid(state, specs, path, orbitdata)
        
        # ---------------------------------
        # DEBUGGING OUTPUTS 
        # self.log_results('CONSENSUS PHASE', state, self.results)
        # print(f'length of bundle: {len(self.bundle)}\nbids to rebroadcast: {len(self.bids_to_rebroadcast)}')
        # print(f'bundle:')
        # for req, subtask_index, bid in self.bundle:
        #     req : MeasurementRequest
        #     bid : Bid
        #     id_short = req.id.split('-')[0]
        #     print(f'\t{id_short}, {subtask_index}, {np.round(bid.t_img,3)}, {np.round(bid.bid)}')
        # print('')
        # ---------------------------------

        # only replan if...
        if (
            self.bids_to_rebroadcast                    # there is bid information to broadcast
            #TODO or pending_information_broadcast       # there is relevant information to broadcast
            or (abs(state.t - current_plan.t) <= 1e-3 
                and isinstance(current_plan, Preplan))  # a new preplan was just generated
            ):
            return True
        
        return False
            
    
    def path_from_bundle(self, bundle : list) -> list:
        """ Extracts the sequence of observations being scheduled by a given bundle """
        path = [(req, instrument_name, bid.t_img, bid.th_img, bid.bid)
                for req, instrument_name, bid in bundle
                if isinstance(bid, Bid)]
        
        path.sort(key=lambda a : a[2])

        return path

    @runtime_tracker
    def generate_plan(  self, 
                        state : SimulationAgentState,
                        specs : object,
                        reward_grid ,
                        current_plan : Plan,
                        clock_config : ClockConfig,
                        orbitdata : dict = None
                    ) -> list:
        
        # -------------------------------
        # DEBUG PRINTOUTS
        # self.log_results('PRE-PLANNING PHASE', state, self.results)
        # -------------------------------

        # perform bidding phase
        self.results, self.bundle, self.planner_changes = \
            self.planning_phase(state, specs, self.results, self.bundle, reward_grid, orbitdata)
        
        # -------------------------------
        # DEBUG PRINTOUTS
        # self.log_results('PLANNING PHASE', state, self.results)
        # print(f'bundle:')
        # for req, subtask_index, bid in self.bundle:
        #     req : MeasurementRequest
        #     bid : Bid
        #     req_id_short = req.id.split('-')[0]
        #     print(f'\t{req_id_short}, {subtask_index}, {np.round(bid.t_img,3)}, {np.round(bid.bid)}')
        # print('')
        # -------------------------------

        # schedule observations from bids
        observations : list = self._schedule_observations(state, specs, self.bundle, orbitdata)

        # generate maneuver and travel actions from observations
        maneuvers : list = self._schedule_maneuvers(state, specs, observations, clock_config, orbitdata)

        # schedule broadcasts
        broadcasts : list = self._schedule_broadcasts(state, current_plan, reward_grid, orbitdata)       

        # generate wait actions 
        waits : list = self._schedule_waits(state)
        
        # compile and generate plan
        self.plan = Replan(maneuvers, waits, observations, broadcasts, t=state.t, t_next=self.preplan.t_next)

        return self.plan.copy()
    
    @runtime_tracker
    def _schedule_observations(self, 
                               state : SimulationAgentState, 
                               specs : object, 
                               bundle : list, 
                               orbitdata : OrbitData) -> list:
        """ compiles and merges lists of measurement actions to be performed by the agent """

        # generate plan from path        
        path : list = self.path_from_bundle(bundle)

        # ensure path given was valid
        if self._debug: assert self.is_task_path_valid(state, specs, path, orbitdata)
        
        # merge with preplanned observations
        observations : list[ObservationAction] = self.merge_plans(state, specs, path)
        
        # ensure resulting plan is valid
        if self._debug: assert self.is_observation_path_valid(state, specs, observations)
        
        # return observations
        return observations


    @runtime_tracker
    def merge_plans(self, state : SimulationAgentState, specs : object, path : list) -> list:
        # generate proposed observation actions
        proposed_observations = [ObservationAction(main_measurement, req.target, th_img, t_img)
                                for req, main_measurement, t_img, th_img, _ in path
                                if isinstance(req,TaskRequest)]
        proposed_observations_bckp = [observation for observation in proposed_observations]
        proposed_observations.sort(key=lambda a : a.t_start)

        # check for if the right number of measurements was created
        assert len(proposed_observations) == len(path)

        # gather observations from preplan
        planned_observations = [action for action in self.preplan
                                if isinstance(action, ObservationAction)]
        planned_observations.sort(key=lambda a : a.t_start)

        # combine observation list
        observations = []
        while proposed_observations and planned_observations:
            # get next actions in the lists
            proposed_observation : ObservationAction = proposed_observations[0]
            planned_observation  : ObservationAction = planned_observations[0]

            # construct temporary observation sequence
            temp_observations = [action for action in observations]
            if proposed_observation.t_start <= planned_observation.t_start:
                temp_observations.append(proposed_observation)
            else:
                temp_observations.append(planned_observation)

            # check if the temporary observation sequence is valid
            if self.is_observation_path_valid(state, specs, temp_observations):
                # is valid; remove added action from queue
                if proposed_observation.t_start <= planned_observation.t_start:
                    observations.append(proposed_observations.pop(0))
                else:
                    if (    observations
                        and abs(observations[-1].target[0]-planned_observation.targets[0]) <= 1e-3
                        and abs(observations[-1].target[1]-planned_observation.targets[1]) <= 1e-3
                        and abs(observations[-1].target[2]-planned_observation.targets[2]) <= 1e-3):
                        # is already in plan; ignore
                        planned_observations.pop(0)
                    else:
                        # add to new observations plan
                        observations.append(planned_observations.pop(0))
            else:
                if temp_observations[-1] == proposed_observation:
                    observations.pop()
                else:
                    planned_observations.pop(0)
        
        # check if compiled observations path is valid
        if self._debug: assert self.is_observation_path_valid(state, specs, observations)

        # check if there are still proposed observations to be added to the path
        while proposed_observations:
            # get next actions in the lists
            proposed_observation : ObservationAction = proposed_observations[0]

            # construct temporary observation sequence
            temp_observations = [action for action in observations]
            temp_observations.append(proposed_observation)  

            # check if the temporary observation sequence is valid
            if self.is_observation_path_valid(state, specs, temp_observations):
                # is valid; remove added action from queue
                observations.append(proposed_observations.pop(0))
            else:
                observations.pop()

        # check if compiled observations path is valid
        if self._debug: assert self.is_observation_path_valid(state, specs, observations)

        while planned_observations:
            # get next actions in the lists
            planned_observation  : ObservationAction = planned_observations[0]

            # construct temporary observation sequence
            temp_observations = [action for action in observations]
            temp_observations.append(planned_observation) 

            # check if the temporary observation sequence is valid
            if self.is_observation_path_valid(state, specs, temp_observations):
                # is valid; check if already being observed:
                if (    observations
                    and abs(observations[-1].target[0]-planned_observation.targets[0]) <= 1e-3
                    and abs(observations[-1].target[1]-planned_observation.targets[1]) <= 1e-3
                    and abs(observations[-1].target[2]-planned_observation.targets[2]) <= 1e-3):
                    
                    # is already in plan; ignore
                    planned_observations.pop(0)
                else:
                    # add to new observations plan
                    observations.append(planned_observations.pop(0))
            else:
                planned_observations.pop(0)

        # check if compiled observations path is valid
        if self._debug: assert self.is_observation_path_valid(state, specs, observations)

        # ensure all proposed actions are in the final plan
        if self._debug: assert all([observation in observations for observation in proposed_observations_bckp])

        # return compiled observations path
        return observations
    
    @runtime_tracker
    def _schedule_broadcasts(self, 
                             state: SimulationAgentState, 
                             current_plan: Plan, 
                             reward_grid ,
                             orbitdata: dict
                             ) -> list:
        # initiate broadcasts action list     
        broadcasts : list[BroadcastMessageAction] = []
        
        # compile and sort pending measurement requests based on their start time
        pending_reqs_to_broadcast : list[TaskRequest] = list(self.pending_reqs_to_broadcast) 
        pending_reqs_to_broadcast.sort(key=lambda a : a.t_start)

        # find best path for broadcasts at the current time
        path, t_start = self._create_broadcast_path(state, orbitdata, state.t)

        for req in tqdm(pending_reqs_to_broadcast,
                        desc=f'{state.agent_name}-PLANNER: Scheduling Measurement Request Broadcasts', 
                        leave=False):
            
            # calculate broadcast start time
            if req.t_start > t_start:
                path, t_start = self._create_broadcast_path(state, orbitdata, req.t_start)
                
            # check broadcast feasibility
            if t_start < 0: continue

            # create broadcast action
            msg = MeasurementRequestMessage(state.agent_name, state.agent_name, req.to_dict(), path=path)
            broadcast_action = BroadcastMessageAction(msg.to_dict(), t_start)
            
            # add to list of broadcasts
            broadcasts.append(broadcast_action) 
        
        # compile bids to be broadcasted
        compiled_bids : list[Bid] = [bid for bid in self.bids_to_rebroadcast]
        compiled_bids.extend(self.planner_changes)
        
        # sort and make sure the latest update of each task is broadcasted
        bids : Dict[str, Dict[str, Bid]] = dict()
        for bid_to_rebroadcast in compiled_bids: 
            bid_to_rebroadcast : Bid
            req_id = bid_to_rebroadcast.req_id

            if req_id not in bids:
                bids[req_id] = {}
            
            if bid_to_rebroadcast.main_measurement not in bids[req_id]:
                bids[req_id][bid_to_rebroadcast.main_measurement] = bid_to_rebroadcast

            else:
                current_bid : Bid = bids[req_id][bid_to_rebroadcast.main_measurement]
                if current_bid.t_update <= bid_to_rebroadcast.t_update:
                    bids[req_id][bid_to_rebroadcast.main_measurement] = bid_to_rebroadcast

        # find best path for broadcasts
        relay_path, t_start = self._create_broadcast_path(state, orbitdata, state.t)       

        # schedule bid re-broadcast and planner changes
        bids_out = [MeasurementBidMessage(state.agent_name, state.agent_name, bid_to_rebroadcast.to_dict(), path=relay_path) 
                    for req_id in tqdm(bids, desc=f'{state.agent_name}-PLANNER: Scheduling Bid Broadcasts', leave=False) 
                    for _, bid_to_rebroadcast in bids[req_id].items() 
                    if bid_to_rebroadcast is not None
                    and t_start >=0]
        broadcasts.extend([BroadcastMessageAction(msg.to_dict(), t_start) for msg in bids_out])

        # reset broadcast list
        self.bids_to_rebroadcast = []

        # schedule reward grid sharing
        # collect relevant targets
        bidded_reqs : set[Bid] = {req for req in self.known_reqs 
                                    if req.id in bids}
        bidded_targets : set[tuple] = {(req.target[0], req.target[1])
                                        for req in bidded_reqs
                                        if isinstance(req, TaskRequest)}
        
        # collect latest known observations from targets
        latest_observations : list[ObservationAction] = []
        for lat,lon in bidded_targets:
            for instrument,grid_point in reward_grid.get_target_data(lat,lon).items():
                grid_point : GridPoint

                # collect latest known observation for each ground point
                if grid_point.observations:
                    observations : list[dict] = list(grid_point.observations)
                    observations.sort(key= lambda a: a['t_img'])
                    latest_observations.append((instrument, observations[-1]))

        # prepare reward grid info broadcasts
        instruments_used : set = {instrument for instrument,_ in latest_observations}
        obs_msgs = [ObservationResultsMessage(state.agent_name, 
                                            state.agent_name, 
                                            state.to_dict(), 
                                            {}, 
                                            instrument_used,
                                            [observation_data
                                            for instrument, observation_data in latest_observations
                                            if instrument == instrument_used]
                                            )
                for instrument_used in instruments_used]
        broadcasts.extend([BroadcastMessageAction(msg.to_dict(), t_start) for msg in obs_msgs])

        # ensure the right number of broadcasts were created
        assert len(bids_out) <= len(compiled_bids)

        # schedule observation performed mesasges
        # gather observation plan to be sent out
        plan_out = [action.to_dict()
                    for action in current_plan
                    if isinstance(action,ObservationAction)]

        # check if observations exist in plan
        if plan_out:
            # find best path for broadcasts
            path, t_start = self._create_broadcast_path(state, orbitdata)

            # check feasibility of path found
            if t_start >= 0:
                # create plan message
                msg = PlanMessage(state.agent_name, state.agent_name, plan_out, state.t, path=path)
                
                # add plan broadcast to list of broadcasts
                broadcasts.append(BroadcastMessageAction(msg.to_dict(),t_start))
                
                # add action performance broadcast to plan
                for action_dict in tqdm(plan_out, 
                      desc=f'{state.agent_name}-PLANNER: Pre-Scheduling Broadcasts', 
                      leave=False):

                    # path, t_start = self._create_broadcast_path(state, orbitdata, action_dict['t_end']) # TODO improve runtime when simulatin dynamic network
                    t_start = action_dict['t_end'] # TODO temp solution
                    msg = ObservationPerformedMessage(state.agent_name, state.agent_name, action_dict)
                    if t_start >= 0: broadcasts.append(BroadcastMessageAction(msg.to_dict(),t_start))

        if len(broadcasts) > 1:
            bus_msg = BusMessage(state.agent_name, state.agent_name, [action.msg for action in broadcasts])
            broadcasts = [BroadcastMessageAction(bus_msg.to_dict(), t_start)]

        return broadcasts

    @runtime_tracker
    def _compile_broadcast_bids(self, planner_changes : list) -> list:        
        """ Compiles changes in bids from consensus and planning phase and returns a list of the most updated bids """
        broadcast_bids = {}

        bids = [bid for bid in self.bids_to_rebroadcast]
        bids.extend(planner_changes)
        for bid in bids:
            bid : Bid

            if bid.req_id not in broadcast_bids:
                req : TaskRequest = TaskRequest.from_dict(bid.req)
                broadcast_bids[bid.req_id] = [None for _ in req.dependency_matrix]

            current_bid : Bid = broadcast_bids[bid.req_id][bid.subtask_index]
            
            if (current_bid is None 
                or current_bid in planner_changes
                or bid.bidder == current_bid.bidder
                or bid.t_update >= current_bid.t_update
                ):
                broadcast_bids[bid.req_id][bid.subtask_index] = bid.copy()       

        out = []
        for req_id in broadcast_bids:
            out.extend([bid for bid in broadcast_bids[req_id] if bid is not None])
            
        return out
    
    @runtime_tracker
    def _schedule_waits(self, state : SimulationAgentState) -> list:
        """ schedules periodic rescheduling checks """   
        return []

    """
    -----------------------
        CONSENSUS PHASE
    -----------------------
    """
    @runtime_tracker
    def consensus_phase(  
                                self, 
                                state : SimulationAgentState,
                                results : dict, 
                                bundle : list,
                                bids_received : set,
                                completed_measurements : set,
                                level : int = logging.DEBUG
                            ) -> None:
        """
        Evaluates incoming bids and updates current results and bundle
        """
        
        # check if tasks were performed
        results, bundle, \
            done_changes, done_rebroadcasts = self.check_request_completion(state, results, bundle, completed_measurements, level)

        # check if tasks expired
        results, bundle, \
            exp_changes, exp_rebroadcasts = self.check_request_end_time(state, results, bundle, level)

        # compare bids with incoming messages
        results, bundle, \
            comp_changes, comp_rebroadcasts = self.compare_bids(state, results, bundle, bids_received, level)

        # compile changes
        changes = []
        changes.extend(done_changes)
        changes.extend(exp_changes)
        changes.extend(comp_changes)

        # compile rebroadcasts
        rebroadcasts = []
        rebroadcasts.extend(done_rebroadcasts)
        rebroadcasts.extend(exp_rebroadcasts)
        rebroadcasts.extend(comp_rebroadcasts)

        return results, bundle, changes, rebroadcasts
    
    @runtime_tracker
    def check_request_completion(self, 
                                 state : SimulationAgentState,
                                 results : dict, 
                                 bundle : list, 
                                 completed_measurements : set,
                                 level=logging.DEBUG
                                 ) -> tuple:
        """
        Checks if a subtask or a mutually exclusive subtask has already been performed 

        ### Returns
            - results
            - bundle
            - path
            - changes
        """
        # initialize bundle changes and rebroadcast lists
        changes = []
        rebroadcasts = []

        # update results using incoming messages
        for action in tqdm(completed_measurements,
                           desc=f'{state.agent_name}-CONSENSUS: Updating bids with completed observations\' status',
                           leave=False):
            action : ObservationAction

            # check if observation was performed to respond to a measurement request
            bids : list[Bid] = [results[completed_req.id][action.instrument_name]
                                for completed_req in self._get_completed_request(results, action)
                                if not results[completed_req.id][action.instrument_name].performed]
            for bid in bids:
                # set bid as completed in results
                bid._perform(state.t)
                results[bid.req_id][action.instrument_name] = bid

                # add to changes 
                changes.append(bid.copy())

                # add to rebroadcast lists if parent agent performed the observation
                if bid.winner == state.agent_name: rebroadcasts.append(bid.copy())

        # check for task completion in bundle
        for task in [(req, instrument_name, current_bid)
                    for req, instrument_name, current_bid in bundle
                    if results[req.id][instrument_name].performed]:
            ## remove all completed tasks from bundle
            bundle.remove(task)
        
        return results, bundle, changes, rebroadcasts
    
    @runtime_tracker
    def _get_completed_request(self,
                               results : dict, 
                               observation : ObservationAction
                               ) -> set:
        reqs : set[TaskRequest] = {  req 
                                            for req in self.known_reqs
                                            if isinstance(req, TaskRequest)
                                            and req.id in results
                                            and req.t_start-1e-3 <= observation.t_start <= req.t_end+1e-3
                                            and abs(req.target[0] - observation.targets[0]) <= 1e-3
                                            and abs(req.target[1] - observation.targets[1]) <= 1e-3
                                            and abs(req.target[2] - observation.targets[2]) <= 1e-3
                                            and observation.instrument_name in req.observation_types
                                        }

        return reqs

    @runtime_tracker
    def check_request_end_time(self, 
                               state : SimulationAgentState,
                               results : dict, 
                               bundle : list, 
                               level=logging.DEBUG
                               ) -> tuple:
        """
        Checks if measurement requests have expired and can no longer be performed

        ### Returns a tuple with elements:
            - results
            - bundle
            - path
            - changes
            - rebroadcasts 
        """

        # initialize bundle changes and rebroadcast lists
        changes = []
        rebroadcasts = []

        # release tasks from bundle if `t_end` has passed
        expired_tasks = [
            (req, instrument_name, bid) 
            for req,instrument_name,bid in bundle
            if isinstance(req, TaskRequest) 
            and isinstance(bid, Bid)
            and req.t_end < state.t 
            and not bid.performed
        ]

        # if task in the budle has expired, release from bundle with all subsequent tasks
        if expired_tasks:
            expired_index = bundle.index(expired_tasks.pop(0))
            
            for _ in tqdm(range(expired_index, len(bundle)),
                           desc=f'{state.agent_name}-CONSENSUS: Releasing expired tasks from bundle',
                           leave=False):

                # remove from bundle
                measurement_req, instrument_name, bid = bundle.pop(expired_index)
                bid : Bid; measurement_req : TaskRequest

                # reset bid results
                bid._reset(state.t)
                results[measurement_req.id][instrument_name] = bid

                # add to list of changes and rebroadcasts
                changes.append(bid.copy())
                rebroadcasts.append(bid.copy())

        return results, bundle, changes, rebroadcasts

    @runtime_tracker
    def compare_bids(
                    self, 
                    state : SimulationAgentState, 
                    results : dict, 
                    bundle : list, 
                    bids_received : set,
                    level=logging.DEBUG
                    ) -> tuple:
        """
        Compares the existing results with any incoming task bids and updates the bundle accordingly

        ### Returns
            - results
            - bundle
            - path
            - changes
        """
        changes = []
        rebroadcasts = []

        for their_bid in tqdm(bids_received,
                              desc=f'{state.agent_name}-CONSENSUS: Comparing bids',
                              leave=False):
            their_bid : Bid            
            
            # get matching request
            req : TaskRequest = self._get_matching_request(their_bid.req_id)

            if req is None: continue

            # check bids are for new requests
            is_new_req : bool = their_bid.req_id not in results

            if is_new_req:
                # create a new blank bid and save it to results
                bids : set[Bid] = self._generate_bids_from_request(req, state)
                results[their_bid.req_id] = {bid.main_measurement : bid for bid in bids}

                # check who generated the request
                if(their_bid.bidder == state.agent_name   # bid belongs to me
                   and their_bid.winner == their_bid.NONE # task has not been bid on
                   ):
                    # request was generated by me; add to broadcasts
                    my_bid : Bid = results[their_bid.req_id][their_bid.main_measurement]
                    rebroadcasts.append(my_bid.copy())
                                    
            # compare bids
            my_bid : Bid = results[their_bid.req_id][their_bid.main_measurement]
            # self.log(f'comparing bids...\nmine:  {str(my_bid)}\ntheirs: {str(their_bid)}', level=logging.DEBUG) #DEBUG PRINTOUT

            _, rebroadcast_result = my_bid.compare(their_bid)
            updated_bid : Bid = my_bid.update(their_bid, state.t)
            bid_changed = my_bid != updated_bid

            # update results with modified bid
            results[their_bid.req_id][their_bid.main_measurement] = updated_bid
            # self.log(f'\nupdated: {my_bid}\n', level=logging.DEBUG) #DEBUG PRINTOUT
                
            # if relevant changes were made, add to changes and rebroadcast lists respectively
            if bid_changed or is_new_req:
                changes.append(updated_bid)

            if (rebroadcast_result is RebroadcastComparisonResults.REBROADCAST_EMPTY 
                  or rebroadcast_result is RebroadcastComparisonResults.REBROADCAST_SELF):
                rebroadcasts.append(updated_bid)
            elif rebroadcast_result is RebroadcastComparisonResults.REBROADCAST_OTHER:
                rebroadcasts.append(their_bid)

            # if outbid for a bids in the bundle; release outbid and subsequent bids in bundle and path
            if ((req, my_bid.main_measurement, my_bid) in bundle 
                and updated_bid.winner != state.agent_name):

                outbid_index = bundle.index((req, my_bid.main_measurement, my_bid))

                # remove all subsequent bids
                for bundle_index in range(outbid_index, len(bundle)):
                    # remove from bundle
                    measurement_req, main_measurement, current_bid = bundle.pop(outbid_index)

                    # reset bid results
                    measurement_req : TaskRequest; current_bid : Bid
                    if bundle_index > outbid_index:
                        # reset bid
                        current_bid : Bid; current_bid._reset(state.t)

                        # update results
                        results[measurement_req.id][main_measurement] = current_bid

                        rebroadcasts.append(current_bid)
                        changes.append(current_bid)

        return results, bundle, changes, rebroadcasts

    @runtime_tracker
    def _get_matching_request(self, id : list) -> TaskRequest:
        # return next([req for req in self.known_reqs if req.id == id], None)
        
        reqs = {req for req in self.known_reqs if req.id == id}
        return reqs.pop() if reqs else None

    """
    -----------------------
        PLANNING PHASE
    -----------------------
    """
    def _get_bundle_from_preplan(self, 
                                 state : SimulationAgentState, 
                                 reward_grid ,
                                 results : dict, 
                                 bundle : list, 
                                 changes : list) -> tuple:
        # empty bundle and reset results 
        for req, main_measurement, bid in bundle:
            # reset bid
            bid : Bid; bid._reset(state.t)

            # update results dictionary
            req : TaskRequest
            self.results[req.id][main_measurement] = bid
            
            # add bid resets to changes list
            changes.append(bid)

        # empty bundle 
        bundle : list[Bid] = []
        
        # check if new preplan contains observations of known events
        preplanned_tasks = [(req,action) 
                            for req in self.active_requests
                            for action in self.plan
                            if isinstance(action, ObservationAction)
                            and req.t_start <= action.t_start <= req.t_end
                            and abs(req.target[0] - action.targets[0]) <= 1e-3
                            and abs(req.target[1] - action.targets[1]) <= 1e-3
                            and abs(req.target[2] - action.targets[2]) <= 1e-3
                            and action.instrument_name in req.observation_types
                            ]
        
        for req,observation in preplanned_tasks:
            # calculate utility 
            utility = reward_grid.estimate_reward(observation)
            
            # generate bid
            bid = Bid(req.id,
                      observation.instrument_name, 
                      state.agent_name, 
                      utility, 
                      state.agent_name,
                      observation.t_start, 
                      observation.look_angle,
                      self.plan.t 
                    )
            
            # update results
            results[req.id][observation.instrument_name] = bid

            # place in bundle
            bundle.append((req, observation.instrument_name, bid))

            # add bid to changes in results
            changes.append(bid.copy())

            # remove from current plan (will be added back if it wins the bidding process)
            self.plan.remove(observation, state.t)
            self.preplan.remove(observation, state.t)

        # order of bundle construction unknown, assume chronological order
        bundle.sort(key= lambda a : a[2].t_img)
            
        return results, bundle, changes 

    @runtime_tracker
    def planning_phase( self, 
                        state : SimulationAgentState, 
                        specs : object,
                        results : dict, 
                        bundle : list,
                        reward_grid ,
                        orbitdata : OrbitData
                    ) -> tuple:
        """
        Creates a modified plan from all known requests and current plan
        """
        try:
            # initialzie changes and resetted requirement lists
            changes = []
            reset_reqs = []

            # if preplan was just generated, extract bundle from preplan
            if isinstance(self.plan, Preplan):
                results, bundle, changes = self._get_bundle_from_preplan(state, reward_grid, results, bundle, changes)
                        
            # -------------------------------------
            # TEMPORARY FIX: resets bundle and always replans from scratch
            if len(bundle) > 0:
                # reset results
                for req, main_measurement, bid in bundle:
                    # reset bid
                    bid : Bid; bid._reset(state.t)

                    # update results
                    results[req.id][main_measurement] = bid

                    # add to list of resetted requests
                    reset_reqs.append((req,main_measurement))

                # reset bundle 
                bundle = []
            # -------------------------------------
            
            # get requests that can be bid on by this agent
            available_reqs : list[tuple] = self._get_available_requests(state, specs, results, bundle, orbitdata, True)

            if not available_reqs: 
                # no tasks available to be bid on by this agent; return original results
                return results, bundle, changes 

            if not bundle: # bundle is empty; create bundle from scratch
                # generate path 
                max_path = self._generate_path(state, specs, results, available_reqs, reward_grid, orbitdata)

                # update bundle and results 
                for req,main_measurement,t_img,th_img,u_exp in max_path:
                    req : TaskRequest

                    # update bid
                    old_bid : Bid = results[req.id][main_measurement]
                    new_bid : Bid = old_bid.copy()
                    new_bid.set(u_exp, t_img, th_img, state.t)

                    # place in bundle
                    bundle.append((req, main_measurement, new_bid))

                    # if changed, update results
                    if old_bid != new_bid:
                        changes.append(new_bid.copy())
                        results[req.id][main_measurement] = new_bid

                # announce that tasks were reset and were not re-added to the plan
                path_reqs = {(req, main_measurement) 
                            for req,main_measurement,*_ in max_path}
                reset_bids : list[Bid] = [results[req.id][main_measurement]
                                        for req,main_measurement in reset_reqs
                                        if (req,main_measurement) not in path_reqs]
                
                changes.extend(reset_bids)

            else: # add tasks to the bundle
                raise NotImplementedError('Repairing bundle not yet implemented')

            # return results
            return results, bundle, changes 
        
        finally:                    
            if self._debug: 
                # construct observation sequence from bundle
                path = self.path_from_bundle(bundle)

                # check if path is valid
                assert self.is_task_path_valid(state, specs, path, orbitdata)
        
    @runtime_tracker
    def _generate_path(self, 
                       state :SimulationAgentState, 
                       specs : object, 
                       results : dict, 
                       available_reqs : list, 
                       reward_grid ,
                       orbitdata : OrbitData) -> list:
        
        # sort requests by severity in ascending order
        available_reqs.sort(key=lambda a : a[0].severity, reverse=True)

        # initialize max path
        max_path = []
        max_path_utility = 0.0

        # do iterative greedy addition of requests to the path
        for req, main_measurement in tqdm(available_reqs,
                                          desc=f'{state.agent_name}-PLANNER: Generating Bundle',
                                          leave=False):
            req : TaskRequest; main_measurement : str
            
            max_path_j = [path_element for path_element in max_path]
            max_path_utility_j = max_path_utility

            # find best placement for task in path
            for i in range(len(max_path)+1):
            
                # copy current path
                path_j = [path_element_i for path_element_i in max_path]
                
                # add request to path
                path_j.insert(i, (req, main_measurement, -1, -1))
                
                # estimate observation time and look angle
                t_img,th_img = self.calc_imaging_time(state, specs, path_j, req, main_measurement, orbitdata)
                
                if t_img < 0.0: continue # no valid imaging time found; skip

                # calculate performance
                observation = ObservationAction(main_measurement, req.target, th_img, t_img)
                u_exp = reward_grid.estimate_reward(observation)

                # update path values
                path_j[i] = (req, main_measurement, t_img, th_img, u_exp)

                # only add to queue if the path can be performed
                if self.is_task_path_valid(state, specs, path_j, orbitdata): 
                    # create potential bids for observations in the path
                    path_bids : list[Bid] = [Bid(req.id, 
                                                main_measurement, 
                                                state.agent_name, 
                                                u_exp, 
                                                t_img=t_img, 
                                                th_img=th_img)
                                            for req,main_measurement,t_img,th_img,u_exp in path_j
                                            if isinstance(req,TaskRequest)]
                                            
                    # calculate path utility 
                    path_utility : float = self.calc_path_utility(state, specs, path_j, reward_grid)

                    # check if it outbids competitors
                    if (path_utility > max_path_utility_j                           # path utility is increased
                        and all([results[bid.req_id][bid.main_measurement] < bid    # all new bids outbid competitors
                                for bid in path_bids])
                        ):
                        # outbids competitors; set new max utility path
                        max_path_j = [path_element for path_element in path_j]
                        max_path_utility_j = path_utility

            # update best path 
            if max_path_utility_j > max_path_utility:
                max_path = [path_element for path_element in max_path_j]

        # return path of maximum utility
        return max_path
        
    @runtime_tracker
    def calc_path_utility(self, 
                          state : SimulationAgentState, 
                          specs : object, 
                          path : list, 
                          reward_grid 
                          ) -> float:
        # merge current path with preplan
        observations : list[ObservationAction] = self.merge_plans(state, specs, path)

        # sum estimated rewards
        return sum([reward_grid.estimate_reward(observation) for observation in observations])

    @runtime_tracker
    def _get_available_requests(self, 
                                state : SimulationAgentState, 
                                specs : object,
                                results : dict, 
                                bundle : list,
                                orbitdata : OrbitData,
                                sort : bool = False
                                ) -> list:
        """ Returns a list of known requests that can be performed within the current planning horizon """
        # find requests that are known of an are available
        available_reqs : set[TaskRequest] \
            = { req for req in self.known_reqs
                if req.t_start <= state.t <= req.t_end
                and req.id in results}

        # find requests that can be bid on
        biddable_reqs = [(req, main_measurement)
                         for req in available_reqs
                         for main_measurement in req.observation_types
                         if self._can_bid(state, specs, results, req, main_measurement)
                         and self._can_access(state, req, orbitdata)
                         and (req, main_measurement, results[req.id][main_measurement]) not in bundle
                         and not self.__request_has_been_performed(results, req, main_measurement, state.t)
                         ]

        # sorting is not requred, return list of requests
        if not sort: return biddable_reqs

        # sorts list of available requests based on earliest access times
        available_reqs_accesses = []
        for req,main_measurement in biddable_reqs:
            req : TaskRequest; main_measurement : str
            
            # find access times for a given request
            req_accesses = [
                (t_img*orbitdata.time_step,req.id,req,main_measurement)
                for t_img,_,_,lat,lon,*_,instrument,_ in orbitdata.gp_access_data.values
                if req.t_start <= t_img*orbitdata.time_step <= req.t_end
                and instrument == main_measurement
                and abs(lat - req.target[0]) <= 1e-3
                and abs(lon - req.target[1]) <= 1e-3
            ]

            # sort in ascending order 
            req_accesses.sort()

            # save only the earliest access time to request target
            available_reqs_accesses.append(req_accesses.pop(0))
        
        # sort requests by ascending access time 
        available_reqs_accesses.sort()

        # return list of available requests sorted by access times
        return [(req,main_measurement) for *_,req,main_measurement in available_reqs_accesses]
        
    @abstractmethod
    def is_task_path_valid(self, state : SimulationAgentState, specs : object, path : list, orbitdata : OrbitData) -> bool:
        pass
   
    @runtime_tracker
    def _can_access( self, 
                     state : SimulationAgentState, 
                     req : TaskRequest,
                     orbitdata : OrbitData = None
                     ) -> bool:
        """ Checks if an agent can access the location of a measurement request """
        if isinstance(state, SatelliteAgentState):
            t_arrivals = [t_img*orbitdata.time_step 
                          for t_img,_,_,lat,lon,*_,instrument,_ in orbitdata.gp_access_data.values
                          if req.t_start <= t_img*orbitdata.time_step <= req.t_end
                          and t_img <= self.preplan.t_next
                          and instrument in req.observation_types
                          and abs(lat - req.target[0]) <= 1e-3
                          and abs(lon - req.target[1]) <= 1e-3
                          ]
            
            return len(t_arrivals) > 0
        else:
            raise NotImplementedError(f"listing of available requests for agents with state of type {type(state)} not yet supported.")

        
    @abstractmethod
    def _can_bid(self, 
                state : SimulationAgentState, 
                specs : object,
                results : dict,
                req : TaskRequest, 
                main_measurement : str
                ) -> bool:
        """ Checks if an agent has the ability to bid on a measurement task """
        pass

    def __request_has_been_performed(self, 
                                     results : dict, 
                                     req : TaskRequest, 
                                     main_measurement : int, 
                                     t : Union[int, float]) -> bool:
        """ Check if subtask at hand has already been performed """
        current_bid : Bid = results[req.id][main_measurement]
        subtask_already_performed = t > current_bid.t_img and current_bid.winner != Bid.NONE

        return subtask_already_performed or current_bid.performed

    @abstractmethod
    def calc_imaging_time(self, state : SimulationAgentState, specs : object, path : list, req : TaskRequest, main_measurement : str, orbitdata : OrbitData) -> float:
        """
        Computes the ideal" time when a task in the path would be performed
        ### Returns
            - t_img (`float`): earliest available imaging time
        """
        pass  

    """
    --------------------
    LOGGING AND TEARDOWN
    --------------------
    """
    @abstractmethod
    def log_results(self, dsc : str, state : SimulationAgentState, results : dict, level=logging.DEBUG) -> None:
        """
        Logs current results at a given time for debugging purposes

        ### Argumnents:
            - dsc (`str`): description of what is to be logged
            - results (`dict`): results to be logged
            - level (`int`): logging level to be used
        """
        pass
    
    def log_task_sequence(self, dsc : str, sequence : list, level=logging.DEBUG) -> None:
        """
        Logs a sequence of tasks at a given time for debugging purposes

        ### Argumnents:
            - dsc (`str`): description of what is to be logged
            - sequence (`list`): list of tasks to be logged
            - level (`int`): logging level to be used
        """
        out = f'\n{dsc} = ['
        for req, subtask_index in sequence:
            req : TaskRequest
            subtask_index : int
            split_id = req.id.split('-')
            
            if sequence.index((req, subtask_index)) > 0:
                out += ', '
            out += f'({split_id[0]}, {subtask_index})'
        out += ']\n'
        print(out) 